(**************************************************************************)
(*       ___                                                              *)
(*      ||M||                                                             *)
(*      ||A||       A project by Andrea Asperti                           *)
(*      ||T||                                                             *)
(*      ||I||       Developers:                                           *)
(*      ||T||         The HELM team.                                      *)
(*      ||A||         http://helm.cs.unibo.it                             *)
(*      \   /                                                             *)
(*       \ /        This file is distributed under the terms of the       *)
(*        v         GNU General Public License Version 2                  *)
(*                                                                        *)
(**************************************************************************)

include "ground_2/xoa/xoa2.ma".
include "basic_2/notation/relations/lazyor_4.ma".
include "basic_2/relocation/lpx_sn_alt.ma".
include "basic_2/substitution/cofrees.ma".

(* POINTWISE UNION FOR LOCAL ENVIRONMENTS ***********************************)

inductive clor (T) (L2) (I) (K1) (V1): predicate term ‚âù
| clor_sn: |K1| < |L2| ‚Üí |L2|-|K1|-1 ~œµ ùêÖ*‚¶ÉK1, T‚¶Ñ ‚Üí clor T L2 I K1 V1 V1
| clor_dx: ‚àÄK2,V2. |K1| < |L2| ‚Üí (|L2|-|K1|-1 ~œµ ùêÖ*‚¶ÉK1, T‚¶Ñ ‚Üí ‚ä•) ‚Üí
           ‚á©[|L2|-|K1|-1] L2 ‚â° K2.‚ìë{I}V2 ‚Üí clor T L2 I K1 V1 V2
.

definition llor: relation4 term lenv lenv lenv ‚âù
                 ŒªT,L2. lpx_sn (clor T L2).

interpretation
   "lazy union (local environment)"
   'LazyOr L1 T L2 L = (llor T L2 L1 L).

(* Basic properties *********************************************************)

lemma llor_pair_sn: ‚àÄI,L1,L2,L,V,T. L1 ‚©ñ[T] L2 ‚â° L ‚Üí
                    |L1| < |L2| ‚Üí |L2|-|L1|-1 ~œµ ùêÖ*‚¶ÉL1, T‚¶Ñ ‚Üí
                    L1.‚ìë{I}V ‚©ñ[T] L2 ‚â° L.‚ìë{I}V.
/3 width=2 by clor_sn, lpx_sn_pair/ qed.

lemma llor_pair_dx: ‚àÄI,L1,L2,L,K2,V1,V2,T. L1 ‚©ñ[T] L2 ‚â° L ‚Üí
                    |L1| < |L2| ‚Üí (|L2|-|L1|-1 ~œµ ùêÖ*‚¶ÉL1, T‚¶Ñ ‚Üí ‚ä•) ‚Üí
                    ‚á©[|L2|-|L1|-1] L2 ‚â° K2.‚ìë{I}V2 ‚Üí
                    L1.‚ìë{I}V1 ‚©ñ[T] L2 ‚â° L.‚ìë{I}V2.
/4 width=3 by clor_dx, lpx_sn_pair/ qed.
(*
lemma llor_total: ‚àÄT,L2,L1. |L1| ‚â§ |L2| ‚Üí ‚àÉL. L1 ‚©ñ[T] L2 ‚â° L.
#T #L2 #L1 elim L1 -L1 /2 width=2 by ex_intro/
#L1 #I1 #V1 #IHL1 normalize
#H elim IHL1 -IHL1 /2 width=3 by transitive_le/
#L #HT elim (cofrees_dec L1 T (|L2|-|L1|-1))
[ /3 width=2 by llor_pair_sn, ex_intro/
| elim (ldrop_O1_lt L2 (|L2|-|L1|-1))
  /5 width=4 by llor_pair_dx, monotonic_lt_minus_l, ex_intro/
| 
]
qed-.
*)
(* Alternative definition ***************************************************)

(* Note: uses minus_minus_comm, minus_plus_m_m, commutative_plus, plus_minus *)
lemma plus_minus_minus_be: ‚àÄx,y,z:nat. y ‚â§ z ‚Üí z ‚â§ x ‚Üí (x - z) + (z - y) = x - y.
#x #z #y #Hzy #Hyx >plus_minus // >commutative_plus >plus_minus //
qed-.

fact plus_minus_minus_be_aux: ‚àÄi,x,y,z:nat. y ‚â§ z ‚Üí z ‚â§ x ‚Üí i = z - y ‚Üí x - z + i = x - y.
/2 width=1 by plus_minus_minus_be/ qed-.

lemma llor_intro_alt: ‚àÄT,L2,L1,L. |L1| ‚â§ |L2| ‚Üí |L1| = |L| ‚Üí
                      (‚àÄI1,I,K1,K,V1,V,i. ‚á©[i] L1 ‚â° K1.‚ìë{I1}V1 ‚Üí ‚á©[i] L ‚â° K.‚ìë{I}V ‚Üí
                         (|L2|-|L1|+i ~œµ ùêÖ*‚¶ÉK1, T‚¶Ñ ‚Üí I1 = I ‚àß V1 = V) ‚àß
                         (‚àÄI2,K2,V2. (|L2|-|L1|+i ~œµ ùêÖ*‚¶ÉK1, T‚¶Ñ  ‚Üí ‚ä•) ‚Üí
                                     ‚á©[|L2|-|L1|+i] L2 ‚â° K2.‚ìë{I2}V2 ‚Üí
                                     ‚àß‚àß I1 = I & I2 = I & V2 = V 
                         )
                      ) ‚Üí L1 ‚©ñ[T] L2 ‚â° L.
#T #L2 #L1 #L #HL12 #HL1 #IH @lpx_sn_intro_alt // -HL1
#I1 #I #K1 #K #V1 #V #i #HLK1 #HLK
lapply (ldrop_fwd_length_minus4 ‚Ä¶ HLK1)
lapply (ldrop_fwd_length_le4 ‚Ä¶ HLK1)
normalize #HKL1 #H1i lapply (plus_minus_minus_be_aux ‚Ä¶ HL12 H1i) // #H2i
lapply (transitive_le ‚Ä¶ HKL1 HL12) -HKL1 -HL12 #HKL1
elim (IH ‚Ä¶ HLK1 HLK) -IH -HLK1 -HLK #IH1 #IH2
elim (cofrees_dec K1 T (|L2|-|L1|+i))
[ -IH2 #HT elim (IH1 ‚Ä¶ HT) -IH1
  /3 width=2 by clor_sn, conj/
| -IH1 #H elim (ldrop_O1_lt L2 (|L2|-|L1|+i)) /2 width=1 by monotonic_lt_minus_l/
  #I2 #K2 #V2 #HLK2 elim (IH2 ‚Ä¶ HLK2) -IH2
  /5 width=3 by clor_dx, ex_intro, and3_intro/
]
qed.

lemma llor_inv_alt: ‚àÄT,L2,L1,L. L1 ‚©ñ[T] L2 ‚â° L ‚Üí |L1| ‚â§ |L2| ‚Üí
                    |L1| = |L| ‚àß
                    (‚àÄI1,I,K1,K,V1,V,i.
                       ‚á©[i] L1 ‚â° K1.‚ìë{I1}V1 ‚Üí ‚á©[i] L ‚â° K.‚ìë{I}V ‚Üí
                       (‚àÉ‚àÉU. ‚áß[|L2|-|L1|+i, 1] U ‚â° T &
                             I1 = I & V1 = V & K1 ‚©ñ[T] L2 ‚â° K
                       ) ‚à®
                       (‚àÉ‚àÉI2,K2,V2. (‚àÄU. ‚áß[|L2|-|L1|+i, 1] U ‚â° T ‚Üí ‚ä•) &
                                    ‚á©[|L2|-|L1|+i] L2 ‚â° K2.‚ìë{I2}V2 &
                                    I1 = I & V2 = V & K1 ‚©ñ[T] L2 ‚â° K
                       )
                    ).
#T #L2 #L1 #L #H #HL12 elim (lpx_sn_inv_alt ‚Ä¶ H) -H
#HL1 #IH @conj // -HL1
#I1 #I #K1 #K #V1 #V #i #HLK1 #HLK
lapply (ldrop_fwd_length_minus4 ‚Ä¶ HLK1)
lapply (ldrop_fwd_length_le4 ‚Ä¶ HLK1)
normalize #HKL1 #H1i lapply (plus_minus_minus_be_aux ‚Ä¶ HL12 H1i) //
lapply (transitive_le ‚Ä¶ HKL1 HL12) -HKL1 -HL12
elim (IH ‚Ä¶ HLK1 HLK) -IH #H *
/4 width=5 by ex5_3_intro, ex4_intro, or_intror, or_introl/
qed-.
