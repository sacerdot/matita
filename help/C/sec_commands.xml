
<!-- ============ Commands ====================== -->
<chapter id="sec_commands">
 <title>Other commands</title>
 <sect1 id="command_alias">
   <title>alias</title>
   <para><userinput>alias id &quot;s&quot; = &quot;def&quot;</userinput></para>
   <para><userinput>alias symbol &quot;s&quot; (instance n) = &quot;def&quot;</userinput></para>
   <para><userinput>alias num (instance n) = &quot;def&quot;</userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">alias</emphasis>
            [<emphasis role="bold">id</emphasis> &qstring; <emphasis role="bold">=</emphasis> &qstring;
            | <emphasis role="bold">symbol</emphasis> &qstring; [<emphasis role="bold">(instance</emphasis> &nat;<emphasis role="bold">)</emphasis>] <emphasis role="bold">=</emphasis> &qstring;
            | <emphasis role="bold">num</emphasis> [<emphasis role="bold">(instance</emphasis> &nat;<emphasis role="bold">)</emphasis>] <emphasis role="bold">=</emphasis> &qstring;
            ]
           </para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>Used to give an hint to the disambiguating parser.
            When the parser is faced to the identifier (or symbol)
            <command>s</command> or to any number, it will prefer
            interpretations that &quot;map <command>s</command> (or the
            number) to <command>def</command>&quot;. For identifiers,
            &quot;def&quot; is the URI of the interpretation.
            E.g.: <command>cic:/matita/nat/nat.ind#xpointer(1/1/1)</command>
            for the first constructor of the first inductive type defined
            in the block of inductive type(s)
            <command>cic:/matita/nat/nat.ind</command>.
            For symbols and numbers, &quot;def&quot; is the label used to
            mark the wanted
            <link linkend="interpretation">interpretation</link>.
           </para>
          <para>When a symbol or a number occurs several times in the
           term to be parsed, it is possible to give an hint only for the
           instance <command>n</command>. When the instance is omitted,
           the hint is valid for every occurrence.
          </para>
          <para>
           Hints are automatically inserted in the script by Matita every
           time the user is interactively asked a question to disambiguate
           a term. This way the user won't be posed the same question twice
           when the script will be executed again.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
 <sect1 id="command_check">
   <title>check</title>
   <para><userinput>check t</userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">check</emphasis> &term;</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>Opens a CIC browser window that shows <command>t</command>
            together with its type. The command is immediately removed from
            the script.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
 <sect1 id="command_coercion">
   <title>coercion</title>
   <para><userinput>coercion u</userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">coercion</emphasis> &uri;</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>Declares <command>u</command> as an implicit coercion
            from the type of its last argument (source)
            to its codomain (target). Every time a term <command>x</command>
            of type source is used with expected type target, Matita
            automatically replaces <command>x</command> with
            <command>(u ? … ? x)</command> to avoid a typing error.</para>
           <para>Implicit coercions are not displayed to the user:
            <command>(u ? … ? x)</command> is rendered simply
            as <command>x</command>.</para>
           <para>When a coercion <command>u</command> is declared
            from source <command>s</command> to target <command>t</command>
            and there is already a coercion <command>u'</command> of
            target <command>s</command> or source <command>t</command>,
            a composite implicit coercion is automatically computed
            by Matita.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
 <sect1 id="command_default">
   <title>default</title>
   <para><userinput></userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">default</emphasis>
           </para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>&TODO;</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
 <sect1 id="command_hint">
   <title>hint</title>
   <para><userinput>hint</userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">hint</emphasis>
           </para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>Displays a list of theorems that can be successfully
            applied to the current selected sequent. The command is
            removed from the script, but the window that displays the
            theorems allow to add to the script the application of the
            selected theorem.
           </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
 <sect1 id="command_include">
   <title>include</title>
   <para><userinput>include &quot;s&quot;</userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">include</emphasis> &qstring;</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>Every <link linkend="command_coercion">coercion</link>,
            <link linkend="notation">notation</link> and
            <link linkend="interpretation">interpretation</link> that was active
            when the file <command>s</command> was compiled last time
            is made active. The same happens for declarations of
            <link linkend="command_default">default definitions and
            theorems</link> and disambiguation
            hints (<link linkend="command_alias">aliases</link>).
            On the contrary, theorem and definitions declared in a file can be
           immediately used without including it.</para>
          <para>The file <command>s</command> is automatically compiled
           if it is not compiled yet and if it is handled by a
           <link linkend="developments">development</link>.
          </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
 <sect1 id="command_include_first">
   <title>include' &quot;s&quot;</title>
   <para><userinput></userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">include'</emphasis> &qstring;</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>Not documented (&TODO;), do not use it.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
 <sect1 id="command_set">
   <title>set</title>
   <para><userinput>set &quot;baseuri&quot; &quot;s&quot;</userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">set</emphasis> &qstring; &qstring;</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>Sets to <command>s</command> the baseuri of all the
            theorems and definitions stated in the current file.
            The baseuri should be <command>a/b/c/foo</command>
            if the file is named <command>foo</command> and it is in
            the subtree <command>a/b/c</command> of the current
            <link linkend="developments">development</link>.
            This requirement is not enforced, but it could be in the future.
           </para>
           <para>Currently, <command>baseuri</command> is the only
            property that can be set even if the parser accepts
            arbitrary property names.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
 <sect1 id="command_whelp">
   <title>whelp</title>
   <para><userinput></userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">whelp</emphasis>
           </para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>&TODO;</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
 <sect1 id="command_qed">
   <title>qed</title>
   <para><userinput></userinput></para>
   <para>
     <variablelist>
       <varlistentry role="tactic.synopsis">
         <term>Synopsis:</term>
         <listitem>
           <para><emphasis role="bold">qed</emphasis>
           </para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term>Action:</term>
         <listitem>
           <para>Saves and indexes the current interactive theorem or
            definition.
            In order to do this, the set of sequents still to be proved
            must be empty.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </sect1>
</chapter>

