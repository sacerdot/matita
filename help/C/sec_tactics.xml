
<!-- ============ Tactics ====================== -->
<chapter id="sec_tactics">
 <title>Tactics</title>

  <sect1 id="tac_absurd">
    <title>absurd &lt;term&gt;</title>
    <para><userinput>absurd P</userinput></para>
     <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para><command>P</command> must have type <command>Prop</command>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it closes the current sequent by eliminating an
             absurd term.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>it opens two new sequents of conclusion <command>P</command>
             and <command>¬P</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
     </para>
  </sect1>
  <sect1 id="tac_apply">
    <title>apply &lt;term&gt;</title>
    <para><userinput>apply t</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para><command>t</command> must have type
             <command>T<subscript>1</subscript> → ... →
              T<subscript>n</subscript> → G</command>
             where <command>G</command> can be unified with the conclusion
             of the current sequent.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it closes the current sequent by applying <command>t</command> to <command>n</command> implicit arguments (that become new sequents).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>it opens a new sequent for each premise 
             <command>T<subscript>i</subscript></command> that is not
             instantiated by unification. <command>T<subscript>i</subscript></command> is
             the conclusion of the <command>i</command>-th new sequent to
             prove.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_assumption">
    <title>assumption</title>
    <para><userinput>assumption </userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>there must exist an hypothesis whose type can be unified with
             the conclusion of the current sequent.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it closes the current sequent exploiting an hypothesis.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_auto">
    <title>auto [depth=&lt;int&gt;] [width=&lt;int&gt;] [paramodulation] [full]</title>
    <para><userinput>auto depth=d width=w paramodulation full</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>none, but the tactic may fail finding a proof if every
             proof is in the search space that is pruned away. Pruning is
             controlled by <command>d</command> and <command>w</command>.
             Moreover, only lemmas whose type signature is a subset of the
             signature of the current sequent are considered. The signature of
             a sequent is ...TODO</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it closes the current sequent by repeated application of
             rewriting steps (unless <command>paramodulation</command> is
             omitted), hypothesis and lemmas in the library.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_clear">
    <title>clear &lt;id&gt;</title>
    <para><userinput>clear H</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para><command>H</command> must be an hypothesis of the
             current sequent to prove.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it hides the hypothesis <command>H</command> from the
             current sequent.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_clearbody">
    <title>clearbody &lt;id&gt;</title>
    <para><userinput>clearbody H</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para><command>H</command> must be an hypothesis of the
             current sequent to prove.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it hides the definiens of a definition in the current
             sequent context. Thus the definition becomes an hypothesis.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_change">
    <title>change &lt;pattern&gt; with &lt;term&gt;</title>
    <para><userinput>change patt with t</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>each subterm matched by the pattern must be convertible
             with the term <command>t</command> disambiguated in the context
             of the matched subterm.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it replaces the subterms of the current sequent matched by
             <command>patt</command> with the new term <command>t</command>.
             For each subterm matched by the pattern, <command>t</command> is
             disambiguated in the context of the subterm.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_constructor">
    <title>constructor &lt;int&gt;</title>
    <para><userinput>constructor n</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>the conclusion of the current sequent must be
             an inductive type or the application of an inductive type.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it applies the <command>n</command>-th constructor of the
             inductive type of the conclusion of the current sequent.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>it opens a new sequent for each premise of the constructor
             that can not be inferred by unification. For more details,
             see the <command>apply</command> tactic.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_contradiction">
    <title>contradiction</title>
    <para><userinput>contradiction </userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>there must be in the current context an hypothesis of type
             <command>False</command>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it closes the current sequent by applying an hypothesis of
             type <command>False</command>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_cut">
    <title>cut &lt;term&gt; [as &lt;id&gt;]</title>
    <para><userinput>cut P as H</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para><command>P</command> must have type <command>Prop</command>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it closes the current sequent.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>it opens two new sequents. The first one has an extra
             hypothesis <command>H:P</command>. If <command>H</command> is
             omitted, the name of the hypothesis is automatically generated.
             The second sequent has conclusion <command>P</command> and
             hypotheses the hypotheses of the current sequent to prove.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_decompose">
    <title>decompose [&lt;ident list&gt;] &lt;ident&gt; [&lt;intros_spec&gt;]</title>
    <para><userinput>decompose ???</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>TODO.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>TODO.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>TODO.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_discriminate">
    <title>discriminate &lt;term&gt;</title>
    <para><userinput>discriminate p</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para><command>p</command> must have type <command>K<subscript>1</subscript> t<subscript>1</subscript> ... t<subscript>n</subscript> = K'<subscript>1</subscript> t'<subscript>1</subscript> ... t'<subscript>m</subscript></command> where <command>K</command> and <command>K'</command> must be different constructors of the same inductive type and each argument list can be empty if
its constructor takes no arguments.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it closes the current sequent by proving the absurdity of
             <command>p</command>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_elim">
    <title>elim &lt;term&gt; [using &lt;term&gt;] [&lt;intros_spec&gt;]</title>
    <para><userinput>elim t using th hyps</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para><command>t</command> must inhabit an inductive type and
             <command>th</command> must be an elimination principle for that
             inductive type. If <command>th</command> is omitted the appropriate
             standard elimination principle is chosen.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it proceeds by cases on the values of <command>t</command>,
             according to the elimination principle <command>th</command>.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>it opens one new sequent for each case. The names of
             the new hypotheses are picked by <command>hyps</command>, if
             provided.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_elimType">
    <title>elimType &lt;term&gt; [using &lt;term&gt;]</title>
    <para><userinput>elimType T using th</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para><command>T</command> must be an inductive type.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>TODO (severely bugged now).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>TODO</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_exact">
    <title>exact &lt;term&gt;</title>
    <para><userinput>exact p</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>the type of <command>p</command> must be convertible
             with the conclusion of the current sequent.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it closes the current sequent using <command>p</command>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_exists">
    <title>exists</title>
    <para><userinput>exists </userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>the conclusion of the current sequent must be
             an inductive type or the application of an inductive type.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>equivalent to <command>constructor 1</command>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>it opens a new sequent for each premise of the first
             constructor of the inductive type that is the conclusion of the
             current sequent. For more details, see the <command>constructor</command> tactic.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_fail">
    <title>fail </title>
    <para><userinput>fail</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>none.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>this tactic always fail.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>N.A.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_fold">
    <title>fold &lt;reduction_kind&gt; &lt;term&gt; &lt;pattern&gt;</title>
    <para><userinput>fold red t patt</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>the pattern must not specify the wanted term.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>first of all it locates all the subterms matched by
             <command>patt</command>. In the context of each matched subterm
             it disambiguates the term <command>t</command> and reduces it
             to its <command>red</command> normal form; then it replaces with
             <command>t</command> every occurrence of the normal form in the
             matched subterm.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_fourier">
    <title>fourier</title>
    <para><userinput>fourier </userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>the conclusion of the current sequent must be a linear
             inequation over real numbers taken from standard library of
             Coq. Moreover the inequations in the hypotheses must imply the
             inequation in the conclusion of the current sequent.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>it closes the current sequent by applying the Fourier method.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>none.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_fwd">
    <title>fwd &lt;ident&gt; [&lt;ident list&gt;]</title>
    <para><userinput>fwd ...TODO</userinput></para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Pre-conditions:</term>
          <listitem>
            <para>TODO.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Action:</term>
          <listitem>
            <para>TODO.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>New sequents to prove:</term>
          <listitem>
            <para>TODO.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  </sect1>
  <sect1 id="tac_generalize">
    <title>generalize &lt;pattern&gt; [as &lt;id&gt;]</title>
    <para>The tactic <command>generalize</command> </para>
  </sect1>
  <sect1 id="tac_id">
    <title>id</title>
    <para>The tactic <command>id</command> </para>
  </sect1>
  <sect1 id="tac_injection">
    <title>injection &lt;term&gt;</title>
    <para>The tactic <command>injection</command> </para>
  </sect1>
  <sect1 id="tac_intro">
    <title>intro [&lt;ident&gt;]</title>
    <para>The tactic <command>intro</command> </para>
  </sect1>
  <sect1 id="tac_intros">
    <title>intros &lt;intros_spec&gt;</title>
    <para>The tactic <command>intros</command> </para>
  </sect1>
  <sect1 id="tac_inversion">
    <title>intros &lt;term&gt;</title>
    <para>The tactic <command>intros</command> </para>
  </sect1>
  <sect1 id="tac_lapply">
    <title>lapply [depth=&lt;int&gt;] &lt;term&gt; [to &lt;term list] [using &lt;ident&gt;]</title>
    <para>The tactic <command>lapply</command> </para>
  </sect1>
  <sect1 id="tac_left">
    <title>left</title>
    <para>The tactic <command>left</command> </para>
  </sect1>
  <sect1 id="tac_letin">
    <title>letin &lt;ident&gt; ≝ &lt;term&gt;</title>
    <para>The tactic <command>letin</command> </para>
  </sect1>
  <sect1 id="tac_normalize">
    <title>normalize &lt;pattern&gt;</title>
    <para>The tactic <command>normalize</command> </para>
  </sect1>
  <sect1 id="tac_paramodulation">
    <title>paramodulation &lt;pattern&gt;</title>
    <para>The tactic <command>paramodulation</command> </para>
  </sect1>
  <sect1 id="tac_reduce">
    <title>reduce &lt;pattern&gt;</title>
    <para>The tactic <command>reduce</command> </para>
  </sect1>
  <sect1 id="tac_reflexivity">
    <title>reflexivity</title>
    <para>The tactic <command>reflexivity</command> </para>
  </sect1>
  <sect1 id="tac_replace">
    <title>replace &lt;pattern&gt; with &lt;term&gt;</title>
    <para>The tactic <command>replace</command> </para>
  </sect1>
  <sect1 id="tac_rewrite">
    <title>rewrite {&lt;|&gt;} &lt;term&gt; &lt;pattern&gt;</title>
    <para>The tactic <command>rewrite</command> </para>
  </sect1>
  <sect1 id="tac_right">
    <title>right</title>
    <para>The tactic <command>right</command> </para>
  </sect1>
  <sect1 id="tac_ring">
    <title>ring</title>
    <para>The tactic <command>ring</command> </para>
  </sect1>
  <sect1 id="tac_simplify">
    <title>simplify &lt;pattern&gt;</title>
    <para>The tactic <command>simplify</command> </para>
  </sect1>
  <sect1 id="tac_split">
    <title>split</title>
    <para>The tactic <command>split</command> </para>
  </sect1>
  <sect1 id="tac_symmetry">
    <title>symmetry</title>
    <para>The tactic <command>symmetry</command> </para>
  </sect1>
  <sect1 id="tac_transitivity">
    <title>transitivity &lt;term&gt;</title>
    <para>The tactic <command>transitivity</command> </para>
  </sect1>
  <sect1 id="tac_unfold">
    <title>unfold [&lt;term&gt;] &lt;pattern&gt;</title>
    <para>The tactic <command>unfold</command> </para>
  </sect1>
  <sect1 id="tac_whd">
    <title>whd &lt;pattern&gt;</title>
    <para>The tactic <command>whd</command> </para>
  </sect1>

</chapter>

