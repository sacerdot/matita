
<!-- =========== Terms, declarations and definitions ============ -->

<chapter id="sec_terms">
  <title>Syntax</title>
  <para>To describe syntax in this manual we use the following conventions:</para>
  <orderedlist>
   <listitem>Non terminal symbols are emphasized and have a link to their definition. E.g.: &term;</listitem>
   <listitem>Terminal symbols are in bold. E.g.: <emphasis role="bold">theorem</emphasis></listitem>
   <listitem>Optional sequences of elements are put in square brackets.
    E.g.: [<emphasis role="bold">in</emphasis> &term;]</listitem>
   <listitem>Alternatives are put in square brakets and they are separated
    by vertical bars. E.g.: [<emphasis role="bold">&lt;</emphasis>|<emphasis role="bold">&gt;</emphasis>]</listitem>
   <listitem>Repetition of sequences of elements are given by putting the
    first sequence in square brackets, that are followed by three dots.
    E.g.: [<emphasis role="bold">and</emphasis> &term;]…</listitem>
  </orderedlist>
  <sect1 id="terms_and_co">
  <title>Terms &amp; co.</title>
  <sect2 id="lexical">
  <title>Lexical conventions</title>
  <table>
    <tgroup>
     <thead />
    <tbody>
     <row>
      <entry id="id">&id;</entry>
      <entry>::=</entry>
      <entry><emphasis>〈〈&TODO;〉〉</emphasis></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <table>
    <tgroup>
     <thead />
    <tbody>
     <row>
      <entry id="nat">&nat;</entry>
      <entry>::=</entry>
      <entry><emphasis>〈〈&TODO;〉〉</emphasis></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <table>
    <tgroup>
     <thead />
    <tbody>
     <row>
      <entry id="uri">&uri;</entry>
      <entry>::=</entry>
      <entry><emphasis>〈〈&TODO;〉〉</emphasis></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect2>
  <sect2 id="terms">
  <title>Terms</title>
  <table>
    <tgroup>
     <thead />
    <tbody>
     <row>
      <entry id="term">&term;</entry>
      <entry>::=</entry>
      <entry>&sterm;</entry>
      <entry>simple or delimited term</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry>&term; &term;</entry>
      <entry>application</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">λ</emphasis>&args;<emphasis role="bold">.</emphasis>&term;</entry>
      <entry>λ-abstraction</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">Π</emphasis>&args;<emphasis role="bold">.</emphasis>&term;</entry>
      <entry>dependent product meant to define a datatype</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">∀</emphasis>&args;<emphasis role="bold">.</emphasis>&term;</entry>
      <entry>dependent product meant to define a proposition</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry>&term; <emphasis role="bold">→</emphasis> &term;</entry>
      <entry>non-dependent product (logical implication or function space)</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">let</emphasis> [&id;|(&id;<emphasis role="bold">:</emphasis> &term;)] <emphasis role="bold">≝</emphasis> &term; <emphasis role="bold">in</emphasis> &term;</entry>
      <entry>local definition</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">let</emphasis>
      [<emphasis role="bold">co</emphasis>]<emphasis role="bold">rec</emphasis>
      &id; [&id;|<emphasis role="bold">(</emphasis>&id;[<emphasis role="bold">,</emphasis>&term;]… <emphasis role="bold">:</emphasis>&term;<emphasis role="bold">)</emphasis>]… [<emphasis role="bold">on</emphasis> &nat;]
      [<emphasis role="bold">:</emphasis> &term;]
      <emphasis role="bold">≝</emphasis> &term;
      </entry>
      <entry>(co)recursive definitions</entry>
     </row>
     <row>
      <entry/>
      <entry/>
      <entry>
      [<emphasis role="bold">and</emphasis>
      [&id;|<emphasis role="bold">(</emphasis>&id;[<emphasis role="bold">,</emphasis>&term;]… <emphasis role="bold">:</emphasis>&term;<emphasis role="bold">)</emphasis>]… [<emphasis role="bold">on</emphasis> &nat;]
      [<emphasis role="bold">:</emphasis> &term;]
      <emphasis role="bold">≝</emphasis> &term;]…
      </entry>
      <entry/>
     </row>
     <row>
      <entry/>
      <entry/>
      <entry>
      <emphasis role="bold">in</emphasis> &term;
      </entry>
      <entry/>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry>…</entry>
      <entry>user provided notation</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
    <tgroup>
     <thead />
    <tbody>
     <row>
      <entry id="sterm">&sterm;</entry>
      <entry>::=</entry>
      <entry><emphasis role="bold">(</emphasis>&term;<emphasis role="bold">)</emphasis></entry>
      <entry/>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry>&id;[<emphasis role="bold">\subst[</emphasis>
       &id;<emphasis role="bold">≔</emphasis>&term;
       [<emphasis role="bold">;</emphasis>&id;<emphasis role="bold">≔</emphasis>&term;]…
       <emphasis role="bold">]</emphasis>]
      </entry>
      <entry>identifier with optional explicit named substitution</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry>&uri;</entry>
      <entry>a qualified reference</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">Prop</emphasis></entry>
      <entry>the impredicative sort of propositions</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">Set</emphasis></entry>
      <entry>the impredicate sort of datatypes</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">Type</emphasis></entry>
      <entry>one predicative sort of datatypes</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">?</emphasis></entry>
      <entry>implicit argument</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">?n</emphasis>
      [<emphasis role="bold">[</emphasis>
      [<emphasis role="bold">_</emphasis>|&term;]…
      <emphasis role="bold">]</emphasis>]</entry>
      <entry>metavariable</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
        <entry><emphasis role="bold">match</emphasis> &term; 
        [ <emphasis role="bold">in</emphasis> &term; ]
        [ <emphasis role="bold">return</emphasis> &term; ]
        <emphasis role="bold">with</emphasis>
      </entry>
      <entry>case analysis</entry>
     </row>
     <row>
      <entry/>
      <entry/>
      <entry>
       <emphasis role="bold">[</emphasis> 
       &match_pattern; <emphasis role="bold"> ⇒ </emphasis> &term;
         [
         <emphasis role="bold">|</emphasis>
         &match_pattern; <emphasis role="bold"> ⇒ </emphasis> &term;
         ]…<emphasis role="bold">]</emphasis> </entry>
      <entry/>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">(</emphasis>&term;<emphasis role="bold">:</emphasis>&term;<emphasis role="bold">)</emphasis></entry>
      <entry>cast</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry>…</entry>
      <entry>user provided notation at precedence 90</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
    <tgroup>
     <thead />
    <tbody>
     <row>
      <entry id="args">&args;</entry>
      <entry>::=</entry>
      <entry>
       <emphasis role="bold">_</emphasis>[<emphasis role="bold">:</emphasis> &term;]
      </entry>
      <entry>ignored argument</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry>
       <emphasis role="bold">(</emphasis><emphasis role="bold">_</emphasis>[<emphasis role="bold">:</emphasis> &term;]<emphasis role="bold">)</emphasis>
      </entry>
      <entry>ignored argument</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry>&id;[<emphasis role="bold">,</emphasis>&id;]…[<emphasis role="bold">:</emphasis> &term;]</entry>
      <entry></entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">(</emphasis>&id;[<emphasis role="bold">,</emphasis>&id;]…[<emphasis role="bold">:</emphasis> &term;]<emphasis role="bold">)</emphasis></entry>
      <entry/>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
    <tgroup>
     <thead />
    <tbody>
     <row>
      <entry id="match_pattern">&match_pattern;</entry>
      <entry>::=</entry>
      <entry>&id;</entry>
      <entry>0-ary constructor</entry>
     </row>
     <row>
      <entry/>
      <entry>|</entry>
      <entry><emphasis role="bold">(</emphasis>&id; &id; [&id;]…<emphasis role="bold">)</emphasis></entry>
      <entry>n-ary constructor (binds the n arguments)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  </sect2>
  </sect1>

  <sect1 id="axiom_definition_declaration">
   <title>Definitions and declarations</title>
   <sect2 id="axiom">
    <title>axiom &id;: &term;</title>
    <titleabbrev>axiom</titleabbrev>
    <para><userinput>axiom H: P</userinput></para>
    <para><command>H</command> is declared as an axiom that states <command>P</command></para>
  </sect2>
  <sect2 id="definition">
    <title>definition &id;[: &term;] [≝ &term;]</title>
    <titleabbrev>definition</titleabbrev>
    <para><userinput>definition f: T ≝ t</userinput></para>
    <para><command>f</command> is defined as <command>t</command>;
     <command>T</command> is its type. An error is raised if the type of
     <command>t</command> is not convertible to <command>T</command>.</para>
    <para><command>T</command> is inferred from <command>t</command> if
      omitted.</para>
    <para><command>t</command> can be omitted only if <command>T</command> is
     given. In this case Matita enters in interactive mode and
     <command>f</command> must be defined by means of tactics.</para>
    <para>Notice that the command is equivalent to <command>theorem f: T ≝ t</command>.</para>
  </sect2>
  <sect2 id="inductive">
    <title>[co]inductive &id; (of inductive types)</title>
    <titleabbrev>(co)inductive types declaration</titleabbrev>
    <para> &TODO; </para>
  </sect2>
  </sect1>

  <sect1 id="proofs">
   <title>Proofs</title>
   <sect2 id="theorem">
    <title>theorem &id;[: &term;] [≝ &term;]</title>
    <titleabbrev>theorem</titleabbrev>
    <para><userinput>theorem f: P ≝ p</userinput></para>
    <para>Proves a new theorem <command>f</command> whose thesis is
     <command>P</command>.</para>
    <para>If <command>p</command> is provided, it must be a proof term for
     <command>P</command>. Otherwise an interactive proof is started.</para>
    <para><command>P</command> can be omitted only if the proof is not
     interactive.</para>
    <para>Proving a theorem already proved in the library is an error.
     To provide an alternative name and proof for the same theorem, use
     <command>variant f: P ≝ p</command>.</para>
    <para>A warning is raised if the name of the theorem cannot be obtained
      by mangling the name of the constants in its thesis.</para>
    <para>Notice that the command is equivalent to <command>definition f: T ≝ t</command>.</para>
   </sect2>
   <sect2 id="variant">
    <title>variant &id;[: &term;] [≝ &term;]</title>
    <titleabbrev>variant</titleabbrev>
    <para><userinput>variant f: T ≝ t</userinput></para>
    <para>Same as <command>theorem f: T ≝ t</command>, but it does not
     complain if the theorem has already been proved. To be used to give
     an alternative name or proof to a theorem.</para>
   </sect2>
   <sect2 id="lemma">
    <title>lemma &id;[: &term;] [≝ &term;]</title>
    <titleabbrev>lemma</titleabbrev>
    <para><userinput>lemma f: T ≝ t</userinput></para>
    <para>Same as <command>theorem f: T ≝ t</command></para>
   </sect2>
   <sect2 id="fact">
    <title>fact &id;[: &term;] [≝ &term;]</title>
    <titleabbrev>fact</titleabbrev>
    <para><userinput>fact f: T ≝ t</userinput></para>
    <para>Same as <command>theorem f: T ≝ t</command></para>
   </sect2>
   <sect2 id="remark">
    <title>remark &id;[: &term;] [≝ &term;]</title>
    <titleabbrev>remark</titleabbrev>
    <para><userinput>remark f: T ≝ t</userinput></para>
    <para>Same as <command>theorem f: T ≝ t</command></para>
   </sect2>
  </sect1>

</chapter>

